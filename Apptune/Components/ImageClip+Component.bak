import SwiftUI

// 1. 首先将 UIImage 扩展移到 struct 外部
extension UIImage {
  func cropped(to rect: CGRect, scale: CGFloat) -> UIImage? {
    let scaledRect = CGRect(
      x: rect.origin.x / scale,
      y: rect.origin.y / scale,
      width: rect.width / scale,
      height: rect.height / scale
    )

    guard let cgImage = cgImage?.cropping(to: scaledRect) else {
      return nil
    }

    return UIImage(cgImage: cgImage)
  }
}

struct ImageClipComponent: View {
  // MARK: - Properties

  @State private var selectedImage: UIImage?  // 选中的图片
  @State private var isShowingImagePicker = false  // 控制图片选择器显示
  @State private var currentTool: EditingTool?  // 当前选中的工具
  @State private var rotation: Double = 0  // 旋转角度
  @State private var selectedRatio: ImageRatio = .free  // 当前选中的裁剪比例
  @State private var cropRect: CGRect = .zero
  @State private var startLocation: CGPoint = .zero
  @State private var isDragging = false
  @State private var imageFrame: CGRect = .zero
  @State private var scale: CGFloat = 1.0  // 添加缩放状态

  private let toolbarHeight: CGFloat = 200  // 工具栏固定高度

  // 添加初始状态记录
  @State private var initialImage: UIImage?  // 记录初始图片
  @State private var initialImageFrame: CGRect = .zero  // 记录初始图片框架

  @State private var dragOffset: CGSize = .zero  // 移到主视图中
  @State private var lastDragOffset: CGSize = .zero  // 移到主视图中

  @State private var imageScale: CGFloat = 1.0  // 图片缩放比例
  @State private var minScale: CGFloat = 1.0  // 最小缩放比例
  @State private var maxScale: CGFloat = 5.0  // 增加最大缩放范围

  @State private var previewTransform: CGAffineTransform = .identity
  @State private var isDraggingImage: Bool = false

  // 添加初始化器
  init(selectedImage: UIImage? = nil) {
    _selectedImage = State(initialValue: selectedImage)
    _initialImage = State(initialValue: selectedImage)
  }

  // MARK: - Body

  var body: some View {
    ZStack {
      // 背景色
      Color.black.edgesIgnoringSafeArea(.all)

      VStack(spacing: 0) {
        Spacer(minLength: 44)  // 顶部预留空间

        // 图片编辑区域
        GeometryReader { geometry in
          ZStack {
            if let image = selectedImage {
              ImageContainer(
                image: image,
                rotation: rotation,
                geometry: geometry,
                imageFrame: $imageFrame,
                imageScale: $imageScale,
                minScale: minScale,
                maxScale: maxScale,
                dragOffset: $dragOffset,
                lastDragOffset: $lastDragOffset,
                isEditingMode: currentTool == .crop,
                cropRect: cropRect
              )
              .overlay(
                Group {
                  if currentTool == .crop {
                    CropOverlay(
                      cropRect: $cropRect,
                      ratio: selectedRatio,
                      imageFrame: imageFrame,
                      onDragEnded: { handleCropAndScale(geometry) }
                    )
                  }
                }
              )
              .onChange(of: currentTool) { tool in
                if tool == .crop {
                  initializeCropRect(in: imageFrame.size)
                }
              }
              .onChange(of: selectedRatio) { _ in
                if currentTool == .crop {
                  initializeCropRect(in: imageFrame.size)
                }
              }
              .onAppear {
                // 记录初始状态
                if initialImageFrame == .zero {
                  let size = calculateImageSize(for: image, in: geometry.size)
                  initialImageFrame = CGRect(
                    x: (geometry.size.width - size.width) / 2,
                    y: (geometry.size.height - size.height) / 2,
                    width: size.width,
                    height: size.height
                  )
                  imageFrame = initialImageFrame
                }
              }
            } else {
              Rectangle()
                .fill(Color.gray.opacity(0.3))
                .overlay(
                  Image(systemName: "photo")
                    .font(.system(size: 40))
                    .foregroundColor(.gray)
                )
            }
          }
          .frame(maxWidth: .infinity, maxHeight: .infinity)
        }

        // 底部工具区域
        ZStack(alignment: .bottom) {
          VStack {
            Spacer()
            // 裁剪比例选项
            if currentTool == .crop {
              cropRatioOptionsView
                .transition(.opacity)
            }

            // 底部工具栏
            HStack {
              // 左侧工具栏
              ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 25) {
                  ToolButton(
                    icon: "crop.rotate",
                    title: "旋转"
                  ) {
                    withAnimation {
                      rotation += 90
                    }
                  }

                  ToolButton(
                    icon: "crop",
                    title: "裁剪"
                  ) {
                    withAnimation {
                      currentTool = currentTool == .crop ? nil : .crop
                    }
                  }

                  if currentTool == .crop {
                    // 添加重置按钮
                    ToolButton(
                      icon: "arrow.counterclockwise",
                      title: "重置"
                    ) {
                      resetToInitialState()
                    }
                  }
                }
                .padding(.horizontal, 20)
              }

              Spacer()

              // 右侧确认按钮
              Button(action: {
                confirmCrop()
              }) {
                Text("完成")
                  .font(.system(size: 16, weight: .medium))
                  .foregroundColor(.black)
                  .padding(.horizontal, 25)
                  .padding(.vertical, 10)
                  .background(Color.white)
                  .cornerRadius(20)
              }
            }
          }
          .padding(.horizontal, 20)
        }
        .frame(height: toolbarHeight)
        .background(Color.black)
      }
    }
  }

  // 初始化裁剪框
  private func initializeCropRect(in size: CGSize) {
    // 使用图片框架的尺寸
    let frameWidth = imageFrame.width
    let frameHeight = imageFrame.height

    switch selectedRatio {
    case .free:
      // 自由模式下使用最大用空间
      cropRect = CGRect(
        origin: imageFrame.origin,
        size: CGSize(width: frameWidth, height: frameHeight)
      )

    case .square:
      let sideLength = min(frameWidth, frameHeight)
      cropRect = CGRect(
        x: imageFrame.minX + (frameWidth - sideLength) / 2,
        y: imageFrame.minY + (frameHeight - sideLength) / 2,
        width: sideLength,
        height: sideLength
      )

    case .portrait:
      let width = min(frameWidth, frameHeight * 3 / 4)
      let height = width * 4 / 3
      cropRect = CGRect(
        x: imageFrame.minX + (frameWidth - width) / 2,
        y: imageFrame.minY + (frameHeight - height) / 2,
        width: width,
        height: height
      )

    case .landscape:
      let height = min(frameHeight, frameWidth * 9 / 16)
      let width = height * 16 / 9
      cropRect = CGRect(
        x: imageFrame.minX + (frameWidth - width) / 2,
        y: imageFrame.minY + (frameHeight - height) / 2,
        width: width,
        height: height
      )
    }
  }

  // MARK: - 裁剪比例选项视图

  private var cropRatioOptionsView: some View {
    ScrollView(.horizontal, showsIndicators: false) {
      HStack(spacing: 20) {
        ForEach(ImageRatio.allCases, id: \.self) { ratio in
          Button(action: {
            withAnimation {
              selectedRatio = ratio
              initializeCropRect(in: imageFrame.size)
            }
          }) {
            VStack(spacing: 4) {
              RatioIcon(ratio: ratio)
                .frame(width: 32, height: 32)
              Text(ratio.title)
                .font(.system(size: 12))
            }
            .foregroundColor(selectedRatio == ratio ? .white : .gray)
          }
        }
      }
      .padding(.horizontal, 20)
      .padding(.vertical, 15)
    }
    .background(Color.black.opacity(0.8))
  }

  // 2. 修改 handleCropAndScale 方法，添加 GeometryProxy 参数
  private func handleCropAndScale(_ geometry: GeometryProxy) {
    withAnimation(.easeInOut(duration: 0.3)) {
      // 计算新的缩放比例
      let screenWidth = UIScreen.main.bounds.width
      let scaleFactor = screenWidth / cropRect.width

      // 保存当前裁剪区域的尺寸比例
      let cropAspectRatio = cropRect.width / cropRect.height

      // 裁剪图片
      if let croppedImage = selectedImage?.cropped(to: cropRect, scale: scale) {
        selectedImage = croppedImage

        // 重新计算图片框架
        let newSize = calculateImageSize(for: croppedImage, in: geometry.size)
        imageFrame = CGRect(
          x: (geometry.size.width - newSize.width) / 2,
          y: (geometry.size.height - newSize.height) / 2,
          width: newSize.width,
          height: newSize.height
        )

        // 重置裁剪框到新的图片尺寸
        initializeCropRect(in: newSize)

        // 重置缩放和偏移
        scale = 1.0
      }
    }
  }

  // 4. 添加计算图片尺寸的辅助方法
  private func calculateImageSize(for image: UIImage, in viewSize: CGSize) -> CGSize {
    let imageSize = image.size
    let widthRatio = viewSize.width / imageSize.width
    let heightRatio = viewSize.height / imageSize.height
    let scale = min(widthRatio, heightRatio)

    return CGSize(
      width: imageSize.width * scale,
      height: imageSize.height * scale
    )
  }

  // 添加重置方法
  private func resetToInitialState() {
    guard let image = initialImage else { return }

    withAnimation(.easeInOut(duration: 0.3)) {
      // 恢复初始图片
      selectedImage = image

      // 重置所有状态
      rotation = 0
      scale = 1.0
      currentTool = .crop  // 保持裁剪模式
      selectedRatio = .free
      dragOffset = .zero
      lastDragOffset = .zero

      // 重置图片框架到初始状态
      imageFrame = initialImageFrame

      // 重置裁剪框
      initializeCropRect(in: imageFrame.size)
    }
  }

  // 添加确认裁剪的方法
  private func confirmCrop() {
    guard let image = selectedImage else { return }

    // 计算实际的裁剪区域
    let scaledRect = CGRect(
      x: (cropRect.minX - imageFrame.minX) / imageScale,
      y: (cropRect.minY - imageFrame.minY) / imageScale,
      width: cropRect.width / imageScale,
      height: cropRect.height / imageScale
    )

    if let croppedImage = image.cropped(to: scaledRect, scale: 1.0) {
      selectedImage = croppedImage
      // 重置所有状态
      resetToInitialState()
      currentTool = nil
    }
  }
}

// MARK: - 编辑工具枚举

enum EditingTool {
  case crop
}

// MARK: - 工具按钮组件

struct ToolButton: View {
  let icon: String
  let title: String
  let action: () -> Void

  var body: some View {
    Button(action: action) {
      VStack(spacing: 8) {
        Image(systemName: icon)
          .font(.system(size: 22))
        Text(title)
          .font(.system(size: 12))
      }
      .foregroundColor(.white)
    }
  }
}

// MARK: - 片比例枚举

enum ImageRatio: CaseIterable {
  case free, square, portrait, landscape

  var title: String {
    switch self {
    case .free: return "自由"
    case .square: return "1:1"
    case .portrait: return "3:4"
    case .landscape: return "16:9"
    }
  }
}

// MARK: - 比例图标组件

struct RatioIcon: View {
  let ratio: ImageRatio

  var body: some View {
    ZStack {
      switch ratio {
      case .free:
        Image(systemName: "crop")
      case .square:
        Rectangle()
          .stroke(lineWidth: 1)
      case .portrait:
        Rectangle()
          .stroke(lineWidth: 1)
          .frame(width: 20, height: 26)
      case .landscape:
        Rectangle()
          .stroke(lineWidth: 1)
          .frame(width: 26, height: 20)
      }
    }
  }
}

// MARK: - 裁剪遮罩组件

struct CropOverlay: View {
  @Binding var cropRect: CGRect
  let ratio: ImageRatio
  let imageFrame: CGRect
  let onDragEnded: () -> Void  // 添加回调
  @State private var dragState: DragState = .none
  @State private var initialRect: CGRect = .zero
  @State private var isDragging: Bool = false

  private let handleSize: CGFloat = 44  // 控制点的可触摸区域
  private let handleVisibleSize: CGFloat = 40  // 制点的可见大小

  var body: some View {
    ZStack {
      // 修改遮罩层，确保不会影响底层图片的交互
      Rectangle()
        .fill(Color.black.opacity(0.5))
        .allowsHitTesting(false)  // 禁用遮罩层的点击
        .mask(
          Rectangle()
            .overlay(
              Rectangle()
                .frame(width: cropRect.width, height: cropRect.height)
                .position(x: cropRect.midX, y: cropRect.midY)
                .blendMode(.destinationOut)
            )
        )

      // 裁剪框
      Rectangle()
        .stroke(Color.white, lineWidth: 1)
        .frame(width: cropRect.width, height: cropRect.height)
        .position(x: cropRect.midX, y: cropRect.midY)

      // ��角标记和边线中点
      CropHandles(rect: cropRect, handleSize: handleVisibleSize)

      // 拖拽控制点
      DragHandles(
        rect: cropRect,
        handleSize: handleSize,
        onStartDrag: { location in
          dragState = .dragging(location: location)
        },
        onDrag: updateCropRect,
        onDragEnded: {  // 添加拖拽结束处理
          isDragging = false
          onDragEnded()
        }
      )
    }
  }

  private func updateCropRect(dragLocation: DragLocation, gesture: DragGesture.Value) {
    var newRect = cropRect
    let translation = gesture.translation
    let minSize: CGFloat = 60

    // 开始拖动时记录初始位置
    if !isDragging {
      initialRect = cropRect
      isDragging = true
    }

    switch dragLocation {
    case .top:
      if ratio == .free {
        // 基于初始位置计算新的位置
        let newY = initialRect.minY + translation.height
        let maxY = initialRect.maxY - minSize
        let limitedY = min(max(imageFrame.minY, newY), maxY)

        newRect.size.height = initialRect.maxY - limitedY
        newRect.origin.y = limitedY
      }

    case .bottom:
      if ratio == .free {
        let newMaxY = initialRect.maxY + translation.height
        let minMaxY = initialRect.minY + minSize
        let limitedMaxY = max(min(imageFrame.maxY, newMaxY), minMaxY)

        newRect.size.height = limitedMaxY - initialRect.minY
      }

    case .left:
      if ratio == .free {
        let newX = initialRect.minX + translation.width
        let maxX = initialRect.maxX - minSize
        let limitedX = min(max(imageFrame.minX, newX), maxX)

        newRect.size.width = initialRect.maxX - limitedX
        newRect.origin.x = limitedX
      }

    case .right:
      if ratio == .free {
        let newMaxX = initialRect.maxX + translation.width
        let minMaxX = initialRect.minX + minSize
        let limitedMaxX = max(min(imageFrame.maxX, newMaxX), minMaxX)

        newRect.size.width = limitedMaxX - initialRect.minX
      }

    default:
      break
    }

    cropRect = newRect
  }
}

// MARK: - 拖拽状态

enum DragState {
  case none
  case dragging(location: DragLocation)
}

// MARK: - ���拽位置

enum DragLocation {
  case none, topLeft, topRight, bottomLeft, bottomRight
  case top, bottom, left, right
}

// MARK: - 裁剪框控制点

struct CropHandles: View {
  let rect: CGRect
  let handleSize: CGFloat

  var body: some View {
    ZStack {
      // 四角
      Group {
        // 左上角
        HandleView(size: handleSize, isCorner: true)
          .position(x: rect.minX + 15, y: rect.minY + 15)
        // 右上角
        HandleView(size: handleSize, isCorner: true)
          .rotationEffect(Angle(degrees: 90))
          .position(x: rect.maxX - 15, y: rect.minY + 15)
        // 右下角
        HandleView(size: handleSize, isCorner: true)
          .rotationEffect(Angle(degrees: 180))
          .position(x: rect.maxX - 15, y: rect.maxY - 15)
        // 左下角
        HandleView(size: handleSize, isCorner: true)
          .rotationEffect(Angle(degrees: 270))
          .position(x: rect.minX + 15, y: rect.maxY - 15)
      }

      // 边线中点
      Group {
        // 上边中点
        HandleView(size: handleSize, isHorizontal: true)
          .position(x: rect.midX, y: rect.minY + 1.5)
        // 下边中点
        HandleView(size: handleSize, isHorizontal: true)
          .position(x: rect.midX, y: rect.maxY - 1.5)
        // 左边中点
        HandleView(size: handleSize, isHorizontal: false)
          .position(x: rect.minX + 1.5, y: rect.midY)
        // 右边中点
        HandleView(size: handleSize, isHorizontal: false)
          .position(x: rect.maxX - 1.5, y: rect.midY)
      }
    }
  }
}

// MARK: - 拖拽控制点

struct DragHandles: View {
  let rect: CGRect
  let handleSize: CGFloat
  let onStartDrag: (DragLocation) -> Void
  let onDrag: (DragLocation, DragGesture.Value) -> Void
  let onDragEnded: () -> Void  // 添加拖拽结束回调

  var body: some View {
    ZStack {
      Group {
        makeHandle(at: .topLeft)
        makeHandle(at: .topRight)
        makeHandle(at: .bottomLeft)
        makeHandle(at: .bottomRight)
      }

      Group {
        makeHandle(at: .top)
        makeHandle(at: .bottom)
        makeHandle(at: .left)
        makeHandle(at: .right)
      }
    }
  }

  @ViewBuilder
  private func makeHandle(at location: DragLocation) -> some View {
    let position = handlePosition(for: location)

    Circle()
      .fill(Color.white.opacity(0.001))
      .frame(width: handleSize, height: handleSize)
      .position(position)
      .gesture(
        DragGesture(minimumDistance: 0)
          .onChanged { gesture in
            onStartDrag(location)
            onDrag(location, gesture)
          }
          .onEnded { _ in  // 添加拖���结束处理
            onDragEnded()
          }
      )
  }

  private func handlePosition(for location: DragLocation) -> CGPoint {
    switch location {
    case .topLeft:
      return CGPoint(x: rect.minX, y: rect.minY)
    case .topRight:
      return CGPoint(x: rect.maxX, y: rect.minY)
    case .bottomLeft:
      return CGPoint(x: rect.minX, y: rect.maxY)
    case .bottomRight:
      return CGPoint(x: rect.maxX, y: rect.maxY)
    case .top:
      return CGPoint(x: rect.midX, y: rect.minY)
    case .bottom:
      return CGPoint(x: rect.midX, y: rect.maxY)
    case .left:
      return CGPoint(x: rect.minX, y: rect.midY)
    case .right:
      return CGPoint(x: rect.maxX, y: rect.midY)
    case .none:
      return .zero
    }
  }
}

// MARK: - 控制点视图

struct HandleView: View {
  let size: CGFloat
  let isCorner: Bool
  let isHorizontal: Bool

  init(size: CGFloat, isCorner: Bool = false, isHorizontal: Bool = false) {
    self.size = size
    self.isCorner = isCorner
    self.isHorizontal = isHorizontal
  }

  var body: some View {
    if isCorner {
      // 角落控制点 - L形
      ZStack(alignment: .topLeading) {  // 使用 ZStack 并设置对齐方式
        // 垂直线
        Rectangle()
          .fill(Color.white)
          .frame(width: 3, height: 30)

        // 水平线
        Rectangle()
          .fill(Color.white)
          .frame(width: 30, height: 3)
      }
      .frame(width: 30, height: 30)
    } else {
      // 边线中点 - 单线条
      Rectangle()
        .fill(Color.white)
        .frame(
          width: isHorizontal ? 30 : 3,
          height: isHorizontal ? 3 : 30
        )
    }
  }
}

// MARK: - 图片容器组件

struct ImageContainer: View {
  let image: UIImage
  let rotation: Double
  let geometry: GeometryProxy
  @Binding var imageFrame: CGRect
  @Binding var imageScale: CGFloat
  let minScale: CGFloat
  let maxScale: CGFloat
  @Binding var dragOffset: CGSize
  @Binding var lastDragOffset: CGSize
  let isEditingMode: Bool
  let cropRect: CGRect  // 添加裁剪区域属性

  @State private var dragVelocity: CGSize = .zero
  private let dampingRatio: CGFloat = 0.7  // 添加阻尼系数

  var body: some View {
    let size = calculateImageSize()

    Image(uiImage: image)
      .resizable()
      .scaledToFit()
      .rotationEffect(.degrees(rotation))
      .frame(width: size.width, height: size.height)
      .scaleEffect(imageScale)
      .offset(dragOffset)
      .gesture(
        isEditingMode
          ? SimultaneousGesture(
            DragGesture()
              .onChanged { value in
                // 计算阻尼后的偏移量
                let translation = value.translation
                let dampedTranslation = CGSize(
                  width: translation.width * dampingRatio,
                  height: translation.height * dampingRatio
                )

                // 计算新的偏移量
                let newOffset = CGSize(
                  width: lastDragOffset.width + dampedTranslation.width,
                  height: lastDragOffset.height + dampedTranslation.height
                )

                // 允许临时超出边界的偏移量
                dragOffset = newOffset
                updateImageFrame(size: size)
              }
              .onEnded { value in
                let velocity = CGSize(
                  width: value.predictedEndLocation.x - value.location.x,
                  height: value.predictedEndLocation.y - value.location.y
                )

                // 计算投影位置，考虑惯性
                let projectedOffset = CGSize(
                  width: dragOffset.width + velocity.width * 0.5,
                  height: dragOffset.height + velocity.height * 0.5
                )

                // 使用弹性动画回到有效范围
                withAnimation(.interpolatingSpring(stiffness: 200, damping: 20)) {
                  dragOffset = limitOffsetToCropRect(
                    offset: projectedOffset,
                    imageSize: scaledSize(size),
                    cropRect: cropRect
                  )
                  lastDragOffset = dragOffset
                }
              },
            MagnificationGesture()
              .onChanged { scale in
                let newScale = min(maxScale, max(minScale, scale))
                let newScaledSize = CGSize(
                  width: size.width * newScale,
                  height: size.height * newScale
                )

                // 确保缩放后的图片仍然覆盖裁剪区域
                if canScale(to: newScale, size: size, cropRect: cropRect) {
                  withAnimation(.interactiveSpring()) {
                    imageScale = newScale
                    // 调整偏移量以确保图��仍然覆盖裁剪区域
                    dragOffset = limitOffsetToCropRect(
                      offset: dragOffset,
                      imageSize: newScaledSize,
                      cropRect: cropRect
                    )
                    updateImageFrame(size: size)
                  }
                }
              }
          ) : nil
      )
  }

  // 计算缩放后的尺寸
  private func scaledSize(_ size: CGSize) -> CGSize {
    return CGSize(
      width: size.width * imageScale,
      height: size.height * imageScale
    )
  }

  // 修改限制偏移量的方法，确保图片始终覆盖裁剪区域
  private func limitOffsetToCropRect(offset: CGSize, imageSize: CGSize, cropRect: CGRect) -> CGSize
  {
    let imageFrame = CGRect(
      x: (geometry.size.width - imageSize.width) / 2 + offset.width,
      y: (geometry.size.height - imageSize.height) / 2 + offset.height,
      width: imageSize.width,
      height: imageSize.height
    )

    var limitedOffset = offset

    // 确保图片的四个角不会出现在裁剪区域内部
    // 左边界
    if imageFrame.minX > cropRect.minX {
      limitedOffset.width = cropRect.minX - (geometry.size.width - imageSize.width) / 2
    }

    // 右边界
    if imageFrame.maxX < cropRect.maxX {
      limitedOffset.width = cropRect.maxX - (geometry.size.width + imageSize.width) / 2
    }

    // 上边界
    if imageFrame.minY > cropRect.minY {
      limitedOffset.height = cropRect.minY - (geometry.size.height - imageSize.height) / 2
    }

    // 下边界
    if imageFrame.maxY < cropRect.maxY {
      limitedOffset.height = cropRect.maxY - (geometry.size.height + imageSize.height) / 2
    }

    return limitedOffset
  }

  // 修改缩放检查方法，确保图片始终大于裁剪区域
  private func canScale(to scale: CGFloat, size: CGSize, cropRect: CGRect) -> Bool {
    let newWidth = size.width * scale
    let newHeight = size.height * scale

    // 确保缩放后的尺寸始终大于裁剪区域
    return newWidth >= cropRect.width && newHeight >= cropRect.height
  }

  // 修改更新图片框架的方法
  private func updateImageFrame(size: CGSize) {
    let scaledSize = CGSize(
      width: size.width * imageScale,
      height: size.height * imageScale
    )

    imageFrame = CGRect(
      x: (geometry.size.width - scaledSize.width) / 2 + dragOffset.width,
      y: (geometry.size.height - scaledSize.height) / 2 + dragOffset.height,
      width: scaledSize.width,
      height: scaledSize.height
    )
  }

  // 添加回计算图片尺寸的方法
  private func calculateImageSize() -> CGSize {
    let imageSize = image.size
    let viewSize = geometry.size

    let widthRatio = viewSize.width / imageSize.width
    let heightRatio = viewSize.height / imageSize.height
    let scale = min(widthRatio, heightRatio)

    return CGSize(
      width: imageSize.width * scale,
      height: imageSize.height * scale
    )
  }
}

// MARK: - Preview

struct ImageClipComponent_Previews: PreviewProvider {
  static var previews: some View {
    ImageClipComponent(selectedImage: UIImage(named: "user"))
  }
}

// 添加 Comparable 扩展来支持范围限制
extension Comparable {
  func clamped(to range: ClosedRange<Self>) -> Self {
    return min(max(self, range.lowerBound), range.upperBound)
  }
}
